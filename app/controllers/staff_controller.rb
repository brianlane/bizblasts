class StaffController < ApplicationController
  before_action :set_staff_member, only: [:show, :edit, :update, :destroy, :availability, :update_availability]
  
  def index
    @staff_members = current_business_scope.staff_members.includes(:services)
                                         .order(active: :desc, name: :asc)
  end
  
  def show
    @upcoming_bookings = @staff_member.bookings.upcoming.includes(:service, :tenant_customer)
                                     .limit(10)
  end
  
  def new
    @staff_member = current_business_scope.staff_members.new
    @services = current_business_scope.services.active
  end
  
  def create
    @staff_member = current_business_scope.staff_members.new(staff_member_params)
    
    if @staff_member.save
      redirect_to @staff_member, notice: 'Staff member was successfully created.'
    else
      @services = current_business_scope.services.active
      render :new
    end
  end
  
  def edit
    @services = current_business_scope.services.active
  end
  
  def update
    if @staff_member.update(staff_member_params)
      redirect_to @staff_member, notice: 'Staff member was successfully updated.'
    else
      @services = current_business_scope.services.active
      render :edit
    end
  end
  
  def destroy
    if @staff_member.destroy
      redirect_to staff_index_path, notice: 'Staff member was successfully deleted.'
    else
      redirect_to @staff_member, alert: 'This staff member has associated bookings and cannot be deleted.'
    end
  end
  
  # GET /staff/:id/availability
  def availability
    @date = params[:date] ? Date.parse(params[:date]) : Date.today
    @start_date = @date.beginning_of_week
    @end_date = @date.end_of_week
    
    # Get the calendar data for the entire week
    @calendar_data = AvailabilityService.availability_calendar(
      staff_member: @staff_member,
      start_date: @start_date,
      end_date: @end_date
    )
    
    # Get services this staff member can provide
    @services = @staff_member.services.active
  end
  
  # PATCH /staff/:id/update_availability
  def update_availability
    # Initialize availability data structure
    availability_data = {
      'monday' => [],
      'tuesday' => [],
      'wednesday' => [],
      'thursday' => [],
      'friday' => [],
      'saturday' => [],
      'sunday' => [],
      'exceptions' => {}
    }
    
    # Ensure we update the week the user is actually editing (honours ?date= param)
    @date = params[:date] ? Date.parse(params[:date]) : Date.today
    @start_date = @date.beginning_of_week
    @end_date = @date.end_of_week

    # Primary permitting for the preferred hash-based structure
    availability_params = params.require(:staff_member).require(:availability).permit(
      monday: permit_dynamic_slots,
      tuesday: permit_dynamic_slots,
      wednesday: permit_dynamic_slots,
      thursday: permit_dynamic_slots,
      friday: permit_dynamic_slots,
      saturday: permit_dynamic_slots,
      sunday: permit_dynamic_slots,
      exceptions: {}
    ).to_h

    # No fallback to legacy array-based submission â€“ the app now expects the
    # indexed-hash param structure generated by our forms
    
    # Build day names dynamically based on configured beginning_of_week
    days_of_week = (0..6).map { |d| (@start_date + d.days).strftime('%A').downcase }
    
    days_of_week.each do |day|
      # Check for full-day checkbox first
      full_day_param = params.dig(:full_day, day)
      if full_day_param == '1'
        # Full 24-hour availability
        availability_data[day] = [{
          'start' => '00:00',
          'end' => '23:59'
        }]
        next
      end
      
      day_params = availability_params[day]

      # Skip if nothing was provided for this day and it's not a full-day checkbox
      next if day_params.blank?

      # Extract slots from the hash (keys are arbitrary indices)
      slots = day_params.values.map do |slot_data|
        next unless slot_data.is_a?(Hash)
        start_time = slot_data['start']
        end_time   = slot_data['end']
        if start_time.present? && end_time.present?
          { 'start' => start_time, 'end' => end_time }
        end
      end.compact

      availability_data[day] = slots
    end

    # Update the staff member with the availability data
    if @staff_member.update(availability: availability_data)
      respond_to do |format|
        format.html { redirect_to availability_staff_path(@staff_member, date: @date), notice: 'Availability was successfully updated.' }
        format.json { render json: { success: true, message: 'Availability was successfully updated.' }, status: :ok }
      end
    else
      @date = params[:date] ? Date.parse(params[:date]) : Date.today
      @start_date = @date.beginning_of_week
      @end_date = @date.end_of_week
      
      @calendar_data = AvailabilityService.availability_calendar(
        staff_member: @staff_member,
        start_date: @start_date,
        end_date: @end_date
      )
      
      @services = @staff_member.services.active
      
      respond_to do |format|
        format.html { render :availability }
        format.json { render json: { success: false, errors: @staff_member.errors.full_messages }, status: :unprocessable_entity }
      end
    end
  end
  
  private
  
  def set_staff_member
    @staff_member = current_business_scope.staff_members.find(params[:id])
  end
  
  def staff_member_params
    params.require(:staff_member).permit(
      :name, :email, :phone, :bio, :active, :position, :photo_url,
      service_ids: []
    )
  end
  
  def current_business_scope
    ActsAsTenant.current_tenant || current_user&.business
  end

  # Helper to permit dynamic keys (slot indices) mapping to start/end times
  def permit_dynamic_slots
    # Allows any key (e.g., "0", "1") to contain a hash with "start" and "end"
    Hash.new { |h, k| h[k] = [:start, :end] }
  end
end
