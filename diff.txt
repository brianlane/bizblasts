diff --git a/app/controllers/application_controller.rb b/app/controllers/application_controller.rb
index dce55af..80415b1 100644
--- a/app/controllers/application_controller.rb
+++ b/app/controllers/application_controller.rb
@@ -106,17 +106,29 @@ class ApplicationController < ActionController::Base
     # First get the user via Devise's standard mechanism
     user = super
     return nil unless user
-    
+
+    # Check server-side session blacklist first (immediate invalidation across all domains)
+    if session[:session_token].present? && InvalidatedSession.session_blacklisted?(session[:session_token])
+      AuthenticationTracker.track_event(:session_blacklisted, user: user, request: request,
+                                       session_token: session[:session_token]&.first(8))
+      Rails.logger.info "[current_user] Session blacklisted - user logged out elsewhere"
+      reset_session
+      return nil
+    end
+
     # If session token is present, validate it for global logout functionality
     # If not present (e.g., in tests or legacy sessions), allow the user through
     # This provides security when session tokens exist while maintaining compatibility
     if session[:session_token].present?
       unless user.valid_session?(session[:session_token])
+        AuthenticationTracker.track_event(:session_invalidated, user: user, request: request,
+                                         session_token: session[:session_token]&.first(8))
         Rails.logger.info "[current_user] Session token invalid - user logged out elsewhere"
+        reset_session
         return nil
       end
     end
-    
+
     user
   end
 
@@ -441,13 +453,48 @@ class ApplicationController < ActionController::Base
   def should_attempt_session_restoration?
     # Only attempt for GET and HEAD requests
     return false unless (request.get? || request.head?)
-    
+
     # Skip for asset files and system endpoints
     return false if skip_system_paths?
-    
-    # Attempt session restoration if user likely came from main domain
-    # This is non-blocking - we try to restore their session but don't interrupt navigation
-    likely_cross_domain_user?
+
+    # Multi-signal approach for session restoration detection
+    # Use multiple indicators to determine if user likely has an active session
+    restoration_signals = []
+
+    # Signal 1: HTTP referrer from main domain
+    if likely_cross_domain_user?
+      restoration_signals << :referrer_from_main_domain
+      Rails.logger.debug "[CrossDomainAuth] Signal detected: referrer_from_main_domain"
+    end
+
+    # Signal 2: Recent auth activity for this business
+    if current_tenant && recent_auth_bridge_activity?
+      restoration_signals << :recent_auth_activity
+      Rails.logger.debug "[CrossDomainAuth] Signal detected: recent_auth_activity"
+    end
+
+    # Signal 3: Authentication cookies present (even if expired)
+    if auth_cookies_present?
+      restoration_signals << :auth_cookies_present
+      Rails.logger.debug "[CrossDomainAuth] Signal detected: auth_cookies_present"
+    end
+
+    # Signal 4: User agent suggests returning user (has session storage capabilities)
+    if returning_user_agent?
+      restoration_signals << :returning_user_agent
+      Rails.logger.debug "[CrossDomainAuth] Signal detected: returning_user_agent"
+    end
+
+    # Attempt restoration if we have at least one strong signal
+    should_attempt = restoration_signals.any?
+
+    if should_attempt
+      Rails.logger.info "[CrossDomainAuth] Session restoration signals: #{restoration_signals.join(', ')}"
+    else
+      Rails.logger.debug "[CrossDomainAuth] No session restoration signals detected"
+    end
+
+    should_attempt
   end
   
   def requires_authentication?
@@ -520,6 +567,61 @@ class ApplicationController < ActionController::Base
     # The main solution is to fix the business links to go through the auth bridge
     false
   end
+
+  # Check for recent auth bridge activity for the current business
+  def recent_auth_bridge_activity?
+    return false unless current_tenant
+
+    # Look for auth tokens created in the last 5 minutes for this business
+    AuthToken.where(
+      'created_at > ? AND target_url LIKE ?',
+      5.minutes.ago,
+      "%#{current_tenant.hostname}%"
+    ).exists?
+  rescue => e
+    Rails.logger.debug "[CrossDomainAuth] Error checking recent auth activity: #{e.message}"
+    false
+  end
+
+  # Check if authentication-related cookies are present
+  def auth_cookies_present?
+    # Check for any authentication-related cookies that might indicate a user session
+    session_key = Rails.application.config.session_options[:key] || '_session_id'
+    remember_token_key = 'remember_user_token'
+
+    cookies[session_key].present? ||
+    cookies[remember_token_key].present? ||
+    cookies['_bizblasts_session'].present?
+  rescue => e
+    Rails.logger.debug "[CrossDomainAuth] Error checking auth cookies: #{e.message}"
+    false
+  end
+
+  # Check if user agent suggests a returning user with session capabilities
+  def returning_user_agent?
+    return false unless request.user_agent.present?
+
+    user_agent = request.user_agent.downcase
+
+    # Skip obvious bots and crawlers
+    bot_patterns = [
+      'bot', 'crawler', 'spider', 'scraper', 'checker', 'monitor',
+      'facebook', 'twitter', 'linkedin', 'google', 'bing', 'yahoo',
+      'curl', 'wget', 'postman'
+    ]
+
+    return false if bot_patterns.any? { |pattern| user_agent.include?(pattern) }
+
+    # Look for browsers that support modern session management
+    browser_patterns = [
+      'chrome', 'firefox', 'safari', 'edge', 'opera', 'brave'
+    ]
+
+    browser_patterns.any? { |pattern| user_agent.include?(pattern) }
+  rescue => e
+    Rails.logger.debug "[CrossDomainAuth] Error checking user agent: #{e.message}"
+    false
+  end
   
 
   def redirect_to_auth_bridge
diff --git a/app/controllers/authentication_bridge_controller.rb b/app/controllers/authentication_bridge_controller.rb
index f420566..72805f3 100644
--- a/app/controllers/authentication_bridge_controller.rb
+++ b/app/controllers/authentication_bridge_controller.rb
@@ -15,14 +15,26 @@ class AuthenticationBridgeController < ApplicationController
   # GET /auth/bridge?target_url=https://custom-domain.com/path&business_id=123
   def create
     unless user_signed_in?
+      AuthenticationTracker.track_bridge_failed('unauthenticated', request)
+      Rails.logger.warn "[AuthBridge] Unauthenticated access attempt from #{request.remote_ip}"
       render json: { error: 'Authentication required' }, status: :unauthorized
       return
     end
-    
+
+    # Enhanced security: Check for suspicious request patterns
+    unless valid_bridge_request?
+      AuthenticationTracker.track_suspicious_request(request, 'invalid_bridge_request', user: current_user)
+      Rails.logger.warn "[AuthBridge] Suspicious request pattern from user #{current_user.id}, IP: #{request.remote_ip}"
+      render json: { error: 'Invalid request' }, status: :bad_request
+      return
+    end
+
     target_url = params[:target_url]
     business_id = params[:business_id]
-    
+
     unless valid_target_url?(target_url, business_id)
+      AuthenticationTracker.track_bridge_failed('invalid_target_url', request, user: current_user, target_url: target_url, business_id: business_id)
+      Rails.logger.warn "[AuthBridge] Invalid target URL from user #{current_user.id}: #{target_url&.truncate(100)}"
       render json: { error: 'Invalid target URL' }, status: :bad_request
       return
     end
@@ -79,27 +91,30 @@ class AuthenticationBridgeController < ApplicationController
           target_url,
           request
         )
-      
+
+        # Track successful token creation
+        AuthenticationTracker.track_bridge_created(current_user, target_url, business_id, request)
+
       # Build redirect URL to custom domain's token consumption endpoint
       # This avoids embedding tokens in query params for better security
-      
+
       # Route to the token consumption endpoint on the canonical target domain
       # Use the business canonical host to avoid apexâ†”www 301 hops
       canonical_host_for_redirect = canonical_host
       consumption_url = "#{uri.scheme}://#{canonical_host_for_redirect}"
       consumption_url += ":#{uri.port}" if uri.port && ![80, 443].include?(uri.port)
       consumption_url += "/auth/consume?auth_token=#{CGI.escape(auth_token.token)}"
-      
+
       # Preserve the original target path for after authentication
       if uri.path.present? && uri.path != '/'
         consumption_url += "&redirect_to=#{CGI.escape(uri.path)}"
       end
-      
+
       # Preserve query parameters from original URL
       if uri.query.present?
         consumption_url += "&original_query=#{CGI.escape(uri.query)}"
       end
-      
+
       Rails.logger.info "[AuthBridge] Created auth token for user #{current_user.id}, redirecting to #{uri.host}"
       
       redirect_to consumption_url, allow_other_host: true
@@ -130,11 +145,15 @@ class AuthenticationBridgeController < ApplicationController
       auth_token = AuthToken.consume!(token, request)
       
       unless auth_token
+        AuthenticationTracker.track_bridge_failed('invalid_token', request, token: token&.first(8))
         Rails.logger.warn "[AuthBridge] Invalid or expired token attempted from #{SecurityConfig.client_ip(request)}"
         redirect_to '/', alert: 'Invalid or expired authentication token'
         return
       end
-      
+
+      # Track successful token consumption
+      AuthenticationTracker.track_bridge_consumed(auth_token.user, auth_token, request)
+
       # Sign in the user on this domain
       sign_in(auth_token.user)
       # Rotate session token for extra security and set in session
@@ -498,6 +517,7 @@ class AuthenticationBridgeController < ApplicationController
     
     limit = Rails.env.test? ? 5 : 10
     if attempts >= limit
+      AuthenticationTracker.track_event(:bridge_rate_limited, user: current_user, request: request, attempts: attempts, limit: limit)
       Rails.logger.warn "[AuthBridge] Rate limit exceeded for user #{current_user.id}"
       render json: { error: 'Rate limit exceeded' }, status: :too_many_requests
       return
@@ -507,6 +527,77 @@ class AuthenticationBridgeController < ApplicationController
     Rails.cache.write(cache_key, attempts + 1, expires_in: 1.hour)
   end
   
+  # Enhanced security validation for auth bridge requests
+  def valid_bridge_request?
+    # Check for basic request validity
+    return false unless request.get? || request.head?
+
+    # Check for suspicious user agents (basic bot detection)
+    if request.user_agent.present?
+      user_agent = request.user_agent.downcase
+      suspicious_patterns = [
+        'bot', 'crawler', 'scraper', 'spider', 'scan',
+        'curl', 'wget', 'postman', 'python-requests'
+      ]
+
+      if suspicious_patterns.any? { |pattern| user_agent.include?(pattern) }
+        Rails.logger.debug "[AuthBridge] Suspicious user agent: #{request.user_agent}"
+        return false
+      end
+    end
+
+    # Check for rapid requests (additional to rate limiting)
+    if detect_rapid_requests?
+      Rails.logger.warn "[AuthBridge] Rapid requests detected from user #{current_user.id}"
+      return false
+    end
+
+    # Check referrer validity (should come from our domains)
+    unless valid_referrer?
+      Rails.logger.debug "[AuthBridge] Invalid or missing referrer from user #{current_user.id}"
+      # Don't reject based on referrer alone, but log for monitoring
+    end
+
+    true
+  end
+
+  # Detect rapid successive requests (beyond rate limiting)
+  def detect_rapid_requests?
+    cache_key = "auth_bridge_rapid_check:#{current_user.id}"
+    last_request_time = Rails.cache.read(cache_key)
+    current_time = Time.current
+
+    if last_request_time && (current_time - last_request_time) < 2.seconds
+      AuthenticationTracker.track_event(:rapid_requests, user: current_user, request: request,
+                                       time_between_requests: (current_time - last_request_time).round(2))
+      Rails.cache.write(cache_key, current_time, expires_in: 10.seconds)
+      return true
+    end
+
+    Rails.cache.write(cache_key, current_time, expires_in: 10.seconds)
+    false
+  end
+
+  # Validate referrer comes from expected domains
+  def valid_referrer?
+    return true unless request.referer.present? # Allow missing referrer
+
+    begin
+      referrer_uri = URI.parse(request.referer)
+      expected_domains = if Rails.env.production?
+        ['bizblasts.com', 'www.bizblasts.com']
+      elsif Rails.env.development?
+        ['lvh.me', 'www.lvh.me', 'localhost']
+      else
+        ['example.com', 'www.example.com', 'test.host']
+      end
+
+      expected_domains.include?(referrer_uri.host&.downcase)
+    rescue URI::InvalidURIError
+      false
+    end
+  end
+
   def main_domain_request?
     if Rails.env.development? || Rails.env.test?
       # Development/Test: Handle both lvh.me and example.com domains
@@ -520,7 +611,7 @@ class AuthenticationBridgeController < ApplicationController
         'localhost'         # Local development
       ]
       return true if main_domain_patterns.include?(host)
-      
+
       # Also check for no subdomain or www subdomain on these domains
       host_parts = request.host.split('.')
       if host_parts.length >= 2
@@ -530,29 +621,29 @@ class AuthenticationBridgeController < ApplicationController
           return host_parts.length == 2 || (host_parts.length == 3 && host_parts.first == 'www')
         end
       end
-      
+
       # For localhost or other single-part hosts in test, allow
       true
     else
       # Production: Check for actual main domain patterns
       host = request.host.downcase
-      
+
       # Direct main domain patterns
       main_domain_patterns = [
         'bizblasts.com',
         'www.bizblasts.com',
         'bizblasts.onrender.com'  # Render's internal routing
       ]
-      
+
       return true if main_domain_patterns.include?(host)
-      
+
       # For bizblasts.com, only treat www or no subdomain as main domain
       host_parts = request.host.split('.')
       if host_parts.length >= 2 && host_parts.last(2).join('.') == 'bizblasts.com'
         # Only main domain if no subdomain or www subdomain
         return host_parts.length == 2 || (host_parts.length == 3 && host_parts.first == 'www')
       end
-      
+
       false
     end
   end
diff --git a/app/controllers/users/sessions_controller.rb b/app/controllers/users/sessions_controller.rb
index 724eaf0..ba5a8b5 100644
--- a/app/controllers/users/sessions_controller.rb
+++ b/app/controllers/users/sessions_controller.rb
@@ -68,6 +68,9 @@ module Users
       resource.rotate_session_token!
       session[:session_token] = resource.session_token
 
+      # Track successful session creation
+      AuthenticationTracker.track_session_created(resource, request)
+
       # Store business ID in session if applicable (still useful for other potential logic)
       # This helps with performance and debugging by caching the business association
       if resource.respond_to?(:business) && resource.business.present?
@@ -214,103 +217,46 @@ module Users
     end
 
     # Override Devise's destroy method to handle multi-tenant sign-out
-    # This method needs to:
-    # 1. Determine the current tenant context
-    # 2. Clean up tenant-specific session data
-    # 3. Clear cookies with the correct domain scope
-    # 4. Redirect to the appropriate domain after sign-out
+    # This simplified version uses server-side session blacklisting for reliable cross-domain logout
     def destroy
-      # Invalidate all sessions globally for this user
-      current_user&.invalidate_all_sessions!
-
-      # Check if we're on a subdomain or custom domain
-      # This information is used to determine where to redirect after sign-out
       current_business = ActsAsTenant.current_tenant || find_current_business_from_request
+      logout_user = current_user
 
-      # Track where the request originated
-      request_host = request.host.downcase
+      if logout_user
+        Rails.logger.info "[Sessions::destroy] Starting logout for user #{logout_user.id} from #{request.host}"
 
-      # Was the request served from the business *custom* domain?
-      @was_on_custom_domain = current_business&.host_type_custom_domain? && request_host == current_business.hostname.downcase
+        # Track logout event
+        AuthenticationTracker.track_session_invalidated(logout_user, session[:session_token], request)
 
-      # Was it served from the management *sub-domain* instead?
-      @was_on_management_subdomain = current_business&.host_type_custom_domain? && request_host.ends_with?('.bizblasts.com')
-      
-      # Clear ALL session cookies across all domains to ensure complete logout
-      # This ensures users are logged out from base domain, all subdomains, and custom domains
-      if Rails.env.development? || Rails.env.test?
-        # Development: Clear all possible lvh.me variants
-        domains_to_clear = [
-          nil,           # host-only cookie for current domain
-          '.lvh.me',     # wildcard for all lvh.me subdomains
-          'lvh.me'       # explicit lvh.me domain
-        ]
-        delete_session_cookies_for(domains_to_clear)
-      else
-        # Production: Clear ALL possible domain variants for complete logout
-        domains_to_clear = [
-          nil,                    # host-only cookie for current domain
-          '.bizblasts.com',       # wildcard for all bizblasts.com subdomains
-          'bizblasts.com',        # explicit bizblasts.com domain
-          'www.bizblasts.com'     # explicit www.bizblasts.com domain
-        ]
-        
-        # If we're on a custom domain, also clear its variants
-        if current_business&.host_type_custom_domain?
-          apex_domain = current_business.hostname.sub(/^www\./, '')
-          domains_to_clear += [
-            current_business.hostname,     # explicit custom domain
-            ".#{apex_domain}",            # apex wildcard for custom domain
-            apex_domain                   # explicit apex domain
-          ]
-          # Add www variant if not already included
-          www_domain = "www.#{apex_domain}"
-          domains_to_clear << www_domain unless domains_to_clear.include?(www_domain)
+        # 1. Blacklist current session immediately (server-side, works across all domains)
+        if session[:session_token].present?
+          InvalidatedSession.blacklist_session!(logout_user, session[:session_token])
+          AuthenticationTracker.track_session_blacklisted(logout_user, session[:session_token], 'manual_logout')
+          Rails.logger.info "[Sessions::destroy] Session blacklisted for immediate cross-domain effect"
         end
-        
-        delete_session_cookies_for(domains_to_clear)
+
+        # 2. Invalidate all user sessions globally (rotates session token)
+        logout_user.invalidate_all_sessions!
+
+        # 3. Clear local session and cookies
+        reset_session
+        clear_local_cookies(current_business)
+
+        # 4. Trigger background cleanup for additional tasks
+        CrossDomainLogoutJob.perform_later(logout_user.id, request.remote_ip)
       end
-      
-      # Clear tenant context using ActsAsTenant
-      # This ensures no tenant-specific data remains in the session
+
+      # Clear tenant context
       ActsAsTenant.current_tenant = nil
-      
-      # Call Devise's destroy method with custom redirect logic
-      super do
-        # Determine where to redirect after sign-out
-        if params[:x_logout].present? && @was_on_custom_domain
-          # Second stage: we are now on custom domain; cookies here are cleared, return to platform
-          redirect_url = TenantHost.main_domain_url_for(request, '/')
-          Rails.logger.debug "[Sessions::destroy] Completed cross-domain logout, redirecting to main domain: #{redirect_url}"
-          redirect_to redirect_url, allow_other_host: true and return
-        elsif @was_on_management_subdomain && params[:x_logout].blank?
-          # First stage: called from bizblasts management subdomain â€“ hop to custom domain to clear host-only cookie
-          target_host = current_business.canonical_domain.presence || current_business.hostname
-          if target_host.present?
-            logout_url = "https://#{target_host}/users/sign_out?x_logout=1"
-            Rails.logger.debug "[Sessions::destroy] Redirecting to custom domain for cookie cleanup: #{logout_url}"
-            redirect_to logout_url, allow_other_host: true and return
-          else
-            # Fallback: no valid target host, go straight to main domain
-            redirect_url = TenantHost.main_domain_url_for(request, '/')
-            Rails.logger.debug "[Sessions::destroy] No valid custom domain, redirecting to main domain: #{redirect_url}"
-            redirect_to redirect_url, allow_other_host: true and return
-          end
-        elsif @was_on_custom_domain
-          # Simple logout directly from custom domain (no management subdomain involved)
-          redirect_url = determine_logout_redirect_url(current_business)
-          Rails.logger.debug "[Sessions::destroy] Redirecting from custom domain to: #{redirect_url}"
-          redirect_to redirect_url, allow_other_host: true and return
-        elsif current_business&.host_type_subdomain?
-          # Regular subdomain tenant â€“ after logout go to platform main domain root
-          redirect_url = TenantHost.main_domain_url_for(request, '/')
-          Rails.logger.debug "[Sessions::destroy] Redirecting subdomain logout to main domain: #{redirect_url}"
-          redirect_to redirect_url, allow_other_host: true and return
-        else
-          # User was on the main site, just go to root
-          redirect_to root_path and return
-        end
-      end
+
+      # Handle Devise logout manually to avoid double redirect
+      signed_out = (Devise.sign_out_all_scopes ? sign_out : sign_out(resource_name))
+      set_flash_message! :notice, :signed_out if signed_out
+
+      # Simple redirect logic - no complex two-stage flow needed
+      redirect_url = determine_logout_redirect_url(current_business)
+      Rails.logger.info "[Sessions::destroy] Redirecting to: #{redirect_url}"
+      redirect_to redirect_url, allow_other_host: true
     end
 
     private
@@ -371,6 +317,24 @@ module Users
       sanitized
     end
 
+    # Clear local cookies for the current domain
+    # This is a simplified version of the previous complex multi-domain cookie clearing
+    def clear_local_cookies(current_business)
+      session_key = Rails.application.config.session_options[:key] || :_session_id
+
+      # Clear session cookies for current domain
+      cookies.delete(session_key, path: '/')
+      cookies.delete(:business_id, path: '/')
+
+      # Clear some additional cookies that might be set
+      cookies.delete(:remember_user_token, path: '/') if cookies[:remember_user_token]
+      cookies.delete(:_bizblasts_session, path: '/') if cookies[:_bizblasts_session]
+
+      Rails.logger.debug "[Sessions::clear_local_cookies] Cleared local cookies for #{request.host}"
+    end
+
+    # Legacy method - kept for compatibility but simplified
+    # Note: This method is now primarily used for testing scenarios
     def delete_session_cookies_for(domains)
       session_key = Rails.application.config.session_options[:key] || :_session_id
       domains.uniq.each do |domain_opt|
diff --git a/app/models/auth_token.rb b/app/models/auth_token.rb
index 370d305..3e5b562 100644
--- a/app/models/auth_token.rb
+++ b/app/models/auth_token.rb
@@ -24,20 +24,26 @@ class AuthToken < ApplicationRecord
   # Callbacks
   before_validation :set_token, on: :create
   before_validation :set_expires_at, on: :create
+  before_validation :set_device_fingerprint, on: :create
   
   class << self
       # Generate and store a new auth token
       # @param user [User] The authenticated user
       # @param target_url [String] The destination URL
-      # @param request [ActionDispatch::Request] The HTTP request (for IP and user agent)
+      # @param request [ActionDispatch::Request] The HTTP request (for IP, user agent, and fingerprinting)
       # @return [AuthToken] The created token
       def create_for_user!(user, target_url, request)
-        create!(
+        token = new(
           user: user,
           target_url: target_url,
           ip_address: SecurityConfig.client_ip(request),
           user_agent: request.user_agent
         )
+
+        # Store request temporarily for device fingerprinting
+        token.instance_variable_set(:@creation_request, request)
+        token.save!
+        token
       end
     
     # Find and validate a token
@@ -86,7 +92,14 @@ class AuthToken < ApplicationRecord
           Rails.logger.warn "[AuthToken] User agent mismatch for token #{token_string[0..8]}... (expected: #{token.user_agent}, got: #{current_user_agent})"
           # Don't fail on user agent mismatch (mobile vs desktop, etc) but log it
         end
-        
+
+        # Validate device fingerprint (additional security layer)
+        unless token.validate_device_fingerprint(request)
+          Rails.logger.warn "[AuthToken] Device fingerprint validation failed for token #{token_string[0..8]}..."
+          # For now, log but don't reject - this is primarily for monitoring
+          # In the future, this could be made stricter based on security requirements
+        end
+
         # Mark as used (atomic update)
         token.update!(used: true)
         
@@ -122,7 +135,53 @@ class AuthToken < ApplicationRecord
   def consumable?
     !used? && !expired?
   end
-  
+
+  # Validate device fingerprint with some tolerance for legitimate changes
+  def validate_device_fingerprint(request)
+    return true unless device_fingerprint.present? # Skip validation if no fingerprint stored
+
+    current_fingerprint = generate_device_fingerprint(request)
+
+    if device_fingerprint == current_fingerprint
+      true
+    else
+      Rails.logger.warn "[AuthToken] Device fingerprint mismatch for token #{token[0..8]}..."
+      Rails.logger.debug "[AuthToken] Expected: #{device_fingerprint[0..8]}..., Got: #{current_fingerprint[0..8]}..."
+
+      # Track device mismatch for monitoring
+      AuthenticationTracker.track_device_mismatch(user, self, request)
+
+      # For now, log but don't reject - could be legitimate browser updates
+      # In the future, this could be made stricter based on security requirements
+      true
+    end
+  end
+
+  # Generate device fingerprint from request headers
+  # This creates a hash of browser characteristics that's stable but not too specific
+  def generate_device_fingerprint(request)
+    return nil unless request.respond_to?(:user_agent)
+
+    fingerprint_data = [request.user_agent]
+
+    # Add headers if available (handles both real requests and test mocks)
+    if request.respond_to?(:headers) && request.headers
+      fingerprint_data.concat([
+        request.headers['Accept-Language'],
+        request.headers['Accept-Encoding'],
+        request.headers['Accept']
+      ])
+    end
+
+    fingerprint_data.compact!
+
+    # Return nil if we don't have enough data
+    return nil if fingerprint_data.empty?
+
+    # Create a hash but make it slightly less specific to account for minor variations
+    Digest::SHA256.hexdigest(fingerprint_data.join('|'))[0..31]
+  end
+
   private
   
   def set_token
@@ -133,4 +192,13 @@ class AuthToken < ApplicationRecord
   def set_expires_at
     self.expires_at ||= TOKEN_TTL.from_now
   end
+
+  def set_device_fingerprint
+    return if device_fingerprint.present?
+
+    request = @creation_request
+    return unless request
+
+    self.device_fingerprint = generate_device_fingerprint(request)
+  end
 end
\ No newline at end of file
diff --git a/db/schema.rb b/db/schema.rb
index 51a3925..e5b0f78 100644
--- a/db/schema.rb
+++ b/db/schema.rb
@@ -10,7 +10,7 @@
 #
 # It's strongly recommended that you check this file into your version control system.
 
-ActiveRecord::Schema[8.0].define(version: 2025_09_27_153512) do
+ActiveRecord::Schema[8.0].define(version: 2025_09_28_040506) do
   # These are extensions that must be enabled in order to support this database
   enable_extension "btree_gist"
   enable_extension "pg_catalog.plpgsql"
@@ -100,6 +100,8 @@ ActiveRecord::Schema[8.0].define(version: 2025_09_27_153512) do
     t.datetime "expires_at", null: false
     t.datetime "created_at", null: false
     t.datetime "updated_at", null: false
+    t.string "device_fingerprint"
+    t.index ["device_fingerprint"], name: "index_auth_tokens_on_device_fingerprint"
     t.index ["expires_at"], name: "index_auth_tokens_on_expires_at"
     t.index ["token"], name: "index_auth_tokens_on_token", unique: true
     t.index ["used", "expires_at"], name: "index_auth_tokens_on_used_and_expires_at"
@@ -571,6 +573,19 @@ ActiveRecord::Schema[8.0].define(version: 2025_09_27_153512) do
     t.index ["business_id"], name: "index_integrations_on_business_id"
   end
 
+  create_table "invalidated_sessions", force: :cascade do |t|
+    t.bigint "user_id", null: false
+    t.string "session_token", null: false
+    t.datetime "invalidated_at", null: false
+    t.datetime "expires_at", null: false
+    t.datetime "created_at", null: false
+    t.datetime "updated_at", null: false
+    t.index ["expires_at"], name: "index_invalidated_sessions_on_expires_at"
+    t.index ["session_token"], name: "index_invalidated_sessions_on_session_token", unique: true
+    t.index ["user_id", "session_token"], name: "index_invalidated_sessions_on_user_id_and_session_token"
+    t.index ["user_id"], name: "index_invalidated_sessions_on_user_id"
+  end
+
   create_table "invoices", force: :cascade do |t|
     t.string "invoice_number", null: false
     t.datetime "due_date"
@@ -785,7 +800,7 @@ ActiveRecord::Schema[8.0].define(version: 2025_09_27_153512) do
     t.index ["tenant_customer_id", "created_at"], name: "index_orders_on_tenant_customer_id_and_created_at"
     t.index ["tenant_customer_id"], name: "index_orders_on_tenant_customer_id"
     t.index ["tip_amount"], name: "index_orders_on_tip_amount"
-    t.check_constraint "status::text = ANY (ARRAY['pending_payment'::character varying, 'paid'::character varying, 'cancelled'::character varying, 'shipped'::character varying, 'refunded'::character varying, 'processing'::character varying, 'completed'::character varying, 'business_deleted'::character varying]::text[])", name: "status_enum_check"
+    t.check_constraint "status::text = ANY (ARRAY['pending_payment'::character varying::text, 'paid'::character varying::text, 'cancelled'::character varying::text, 'shipped'::character varying::text, 'refunded'::character varying::text, 'processing'::character varying::text, 'completed'::character varying::text, 'business_deleted'::character varying::text])", name: "status_enum_check"
   end
 
   create_table "page_sections", force: :cascade do |t|
@@ -1684,6 +1699,7 @@ ActiveRecord::Schema[8.0].define(version: 2025_09_27_153512) do
   add_foreign_key "external_calendar_events", "calendar_connections"
   add_foreign_key "integration_credentials", "businesses", on_delete: :cascade
   add_foreign_key "integrations", "businesses", on_delete: :cascade
+  add_foreign_key "invalidated_sessions", "users"
   add_foreign_key "invoices", "bookings", on_delete: :nullify
   add_foreign_key "invoices", "businesses", on_delete: :cascade
   add_foreign_key "invoices", "orders"
