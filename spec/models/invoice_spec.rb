require 'rails_helper'

RSpec.describe Invoice, type: :model do
  let(:business) { create(:business) }
  let(:tenant_customer) { create(:tenant_customer, business: business) }
  let(:shipping_method) { create(:shipping_method, business: business, cost: 10.0) }
  let(:tax_rate_no_shipping) { create(:tax_rate, business: business, rate: 0.1, applies_to_shipping: false) }
  let(:tax_rate_with_shipping) { create(:tax_rate, business: business, rate: 0.08, applies_to_shipping: true) }

  describe 'associations' do
    it { should belong_to(:business) }
    it { should belong_to(:tenant_customer) }
    it { should belong_to(:booking).optional }
    it { should belong_to(:promotion).optional }
    it { should belong_to(:shipping_method).optional }
    it { should belong_to(:tax_rate).optional }
    it { should have_many(:line_items).dependent(:destroy) }
  end

  describe 'validations' do
    subject { build(:invoice, tenant_customer: tenant_customer, business: business) }
    it { should validate_presence_of(:amount) }
    it { should validate_numericality_of(:amount).is_greater_than_or_equal_to(0) }
    it { should validate_presence_of(:total_amount) }
    it { should validate_numericality_of(:total_amount).is_greater_than_or_equal_to(0) }
    it { should validate_presence_of(:due_date) }
    it { should validate_presence_of(:status) }
    # invoice_number is auto-generated by callback, so no presence validation needed
    it { should validate_uniqueness_of(:invoice_number).scoped_to(:business_id) }
    it { should validate_numericality_of(:original_amount).is_greater_than_or_equal_to(0).allow_nil }
    it { should validate_numericality_of(:discount_amount).is_greater_than_or_equal_to(0).allow_nil }
  end

  describe 'callbacks' do
    context 'before_save :calculate_totals' do
      let(:product1) { create(:product, business: business, price: 20.00) }
      let(:variant1) { create(:product_variant, product: product1, price_modifier: 0) }
      let(:product2) { create(:product, business: business, price: 15.00) }
      let(:variant2) { create(:product_variant, product: product2, price_modifier: 0) }
      let!(:invoice) { create(:invoice, tenant_customer: tenant_customer, business: business, shipping_method: shipping_method, line_items: []) }

      before do
        create(:line_item, lineable: invoice, product_variant: variant1, quantity: 2) # Total: 40.00
        create(:line_item, lineable: invoice, product_variant: variant2, quantity: 1) # Total: 15.00
        invoice.reload
        # Line items total = 55.00
        # Shipping = 10.00
      end

      # it 'calculates totals correctly with no tax rate' do
      #   invoice.tax_rate = nil
      #   invoice.save!
      #   expect(invoice.original_amount).to be_within(0.01).of(55.00)
      #   expect(invoice.amount).to be_within(0.01).of(55.00)
      #   expect(invoice.tax_amount).to be_within(0.01).of(0.00)
      #   expect(invoice.total_amount).to be_within(0.01).of(55.00) # 55 + 0
      # end

      # it 'calculates totals correctly with tax rate not applied to shipping' do
      #   invoice.tax_rate = tax_rate_no_shipping # 10% on 55.00 = 5.50
      #   invoice.save!
      #   expect(invoice.original_amount).to be_within(0.01).of(55.00)
      #   expect(invoice.amount).to be_within(0.01).of(55.00)
      #   expect(invoice.tax_amount).to be_within(0.01).of(5.50)
      #   expect(invoice.total_amount).to be_within(0.01).of(60.50) # 55 + 5.50
      # end

      # it 'calculates totals correctly with discount' do
      #   invoice.tax_rate = tax_rate_no_shipping # 10% on discounted amount
      #   invoice.discount_amount = 10.00
      #   invoice.save!
      #   expect(invoice.original_amount).to be_within(0.01).of(55.00)
      #   expect(invoice.amount).to be_within(0.01).of(45.00) # 55 - 10
      #   expect(invoice.tax_amount).to be_within(0.01).of(4.50) # 10% on 45
      #   expect(invoice.total_amount).to be_within(0.01).of(49.50) # 45 + 4.50
      # end
    end

    context 'booking-based invoice calculations' do
      let(:service) { create(:service, business: business, price: 100.00) }
      let(:staff_member) { create(:staff_member, business: business) }
      let(:booking) { create(:booking, business: business, service: service, staff_member: staff_member, tenant_customer: tenant_customer) }
      let(:default_tax_rate) { create(:tax_rate, business: business, name: 'Default Tax', rate: 0.098) }

      it 'calculates totals correctly for booking-based invoice with tax rate' do
        invoice = create(:invoice, :with_booking, business: business, tenant_customer: tenant_customer, booking: booking)
        
        expect(invoice.original_amount).to be_within(0.01).of(100.00)
        expect(invoice.amount).to be_within(0.01).of(100.00)
        expect(invoice.tax_amount).to be_within(0.01).of(9.80) # 9.8% of 100
        expect(invoice.total_amount).to be_within(0.01).of(109.80) # 100 + 9.80
        expect(invoice.tax_rate).to be_present
      end

      it 'calculates totals correctly for booking with product add-ons' do
        # Create products for add-ons
        product = create(:product, business: business, price: 50.00)
        variant = create(:product_variant, product: product, price_modifier: 0)
        
        # Add product add-on to booking
        create(:booking_product_add_on, booking: booking, product_variant: variant, quantity: 2)
        
        invoice = create(:invoice, :with_booking, business: business, tenant_customer: tenant_customer, booking: booking)
        
        # Service: $100, Add-ons: $100 (50 * 2), Total before tax: $200
        expect(invoice.original_amount).to be_within(0.01).of(200.00)
        expect(invoice.amount).to be_within(0.01).of(200.00)
        expect(invoice.tax_amount).to be_within(0.01).of(19.60) # 9.8% of 200
        expect(invoice.total_amount).to be_within(0.01).of(219.60) # 200 + 19.60
      end
    end
  end

  describe '.create_from_estimate' do
    let(:staff_member) { create(:staff_member, business: business) }
    let(:service) { create(:service, business: business, duration: 60, price: 100.0) }
    let(:booking) do
      create(:booking,
        business: business,
        tenant_customer: tenant_customer,
        service: service,
        staff_member: staff_member,
        start_time: 1.week.from_now,
        status: :pending
      )
    end

    context 'when estimate has no required deposit' do
      let(:estimate) do
        est = create(:estimate,
          business: business,
          tenant_customer: tenant_customer,
          booking: booking,
          status: :approved,
          approved_at: Time.current,
          subtotal: 150.0,
          taxes: 15.0,
          total: 165.0,
          required_deposit: nil
        )
        if est.estimate_items.any?
          est.estimate_items.first.update!(service: service, qty: 1, cost_rate: 150.0, tax_rate: 10.0)
          est.save! # Trigger calculate_totals callback
          est.reload # Reload to get updated totals from estimate_items
        end
        est
      end

      it 'creates invoice for the full amount' do
        invoice = Invoice.create_from_estimate(estimate)

        expect(invoice).to be_persisted
        expect(invoice.total_amount).to eq(165.0)
        expect(invoice.amount).to eq(150.0)
        expect(invoice.original_amount).to eq(150.0)
        expect(invoice.tax_amount).to eq(15.0)
        expect(invoice.tenant_customer).to eq(tenant_customer)
        expect(invoice.booking).to eq(booking)
      end

      it 'creates line items from estimate items' do
        invoice = Invoice.create_from_estimate(estimate)

        expect(invoice.line_items.count).to eq(estimate.estimate_items.count)
        invoice.line_items.each_with_index do |line_item, index|
          estimate_item = estimate.estimate_items[index]
          expect(line_item.service).to eq(estimate_item.service)
          expect(line_item.quantity).to eq(estimate_item.qty)
          expect(line_item.price).to eq(estimate_item.cost_rate)
        end
      end
    end

    context 'when estimate has a required deposit' do
      let(:estimate_with_deposit) do
        est = create(:estimate,
          business: business,
          tenant_customer: tenant_customer,
          booking: booking,
          status: :approved,
          approved_at: Time.current,
          subtotal: 150.0,
          taxes: 15.0,
          total: 165.0,
          required_deposit: 50.0
        )
        if est.estimate_items.any?
          est.estimate_items.first.update!(service: service, qty: 1, cost_rate: 150.0, tax_rate: 10.0)
          est.save! # Trigger calculate_totals callback
          est.reload # Reload to get updated totals from estimate_items
        end
        est
      end

      it 'creates invoice for only the deposit amount' do
        invoice = Invoice.create_from_estimate(estimate_with_deposit)

        expect(invoice).to be_persisted
        expect(invoice.total_amount).to eq(50.0)
        expect(invoice.amount).to eq(50.0)
        expect(invoice.original_amount).to eq(50.0)
        expect(invoice.tenant_customer).to eq(tenant_customer)
        expect(invoice.booking).to eq(booking)
      end

      it 'still creates all line items from estimate' do
        invoice = Invoice.create_from_estimate(estimate_with_deposit)

        expect(invoice.line_items.count).to eq(estimate_with_deposit.estimate_items.count)
      end
    end

    context 'when estimate has zero deposit' do
      let(:estimate_zero_deposit) do
        est = create(:estimate,
          business: business,
          tenant_customer: tenant_customer,
          booking: booking,
          status: :approved,
          approved_at: Time.current,
          subtotal: 150.0,
          taxes: 15.0,
          total: 165.0,
          required_deposit: 0.0
        )
        if est.estimate_items.any?
          est.estimate_items.first.update!(service: service, qty: 1, cost_rate: 150.0, tax_rate: 10.0)
          est.save! # Trigger calculate_totals callback
          est.reload # Reload to get updated totals from estimate_items
        end
        est
      end

      it 'creates invoice for the full amount (treats 0 as no deposit)' do
        invoice = Invoice.create_from_estimate(estimate_zero_deposit)

        expect(invoice.total_amount).to eq(165.0)
        expect(invoice.amount).to eq(150.0)
      end
    end
  end
end 